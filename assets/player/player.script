local monarch = require "monarch.monarch"

-- max speed right/left
local max_speed = 450

local input_left = hash("left")
local input_right = hash("right")
local input_up = hash("up")
local input_down = hash("down")
local input_attack = hash("attack")
local display_width = sys.get_config("display.width")
local display_height = sys.get_config("display.height")

function init(self)
	-- Add initialization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed

	-- this lets us handle input in this script
	msg.post(".", "acquire_input_focus")
	
	-- activate camera attached to the player collection
	-- this will send camera updates to the render script
	msg.post("#camera", "acquire_camera_focus")
	msg.post("@render:", "use_camera_projection")

	self.input = vmath.vector3(0,0,0)
	self.direction = 0
	self.health = 100
	msg.post("/level#main_gui", "gui_update", { health = self.health })
	msg.post("#moving", "disable")
	msg.post("healthbar/indicator#healthbar", "health", { max_health = self.health, health = self.health})
	msg.post("healthbar/indicator#healthbar", "follow_me")

	go.set_parent("direction_arrow_pivot", ".", true)
end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

local function attack(self)
	local p = go.get_position()
	local component = "#weapon_factory"
	local props = {}
	props[hash("/weapon")] = { 
		rotation = self.direction
	}
	
	local weapons = collectionfactory.create(component, p, nil, props)
	pprint(weapons)
	pprint(weapons[0])
	local weapon = nil
	-- we assume that only one weapon will be returned
	for k,v in pairs(weapons) do
		weapon = weapons[k]
		break
	end
	-- go.set_parent(mweapon, go.get_id())
	msg.post(weapon, "set_parent", { parent_id = go.get_id(), keep_world_transform = 1 }) -- <7>
end

function update(self, dt)
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed

	local speed = 32 -- pixels per second
	local deltapos = self.input * speed * dt
	go.set_position(go.get_position() + deltapos)

	if vmath.length(self.input) == 0 then
		msg.post("#moving", "disable")
		msg.post("#idle", "enable")
	else
		msg.post("#moving", "enable")
		msg.post("#idle", "disable")
	end
	sprite.set_hflip("#moving", self.input.x < 0)
	self.input = vmath.vector3(0,0,0)

	go.set("direction_arrow_pivot", "euler.z", self.direction-90)
	-- go.set_rotation(vmath.vector3(0,0,self.direction), "direction_arrow_pivot")
	pprint(self.direction)
	-- pprint(go.get_position())
end

function angle_between_vectors(v0, v1)
	-- simplified to two dimensions
	return math.deg(math.atan2(v1.y*v0.x - v1.x*v0.y, v1.x*v0.x + v1.y*v0.y))
end

function fixed_update(self, dt)
	-- This function is called if 'Fixed Update Frequency' is enabled in the Engine section of game.project
	-- Can be coupled with fixed updates of the physics simulation if 'Use Fixed Timestep' is enabled in
	-- Physics section of game.project
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

local function take_damage(self, dmg)
	particlefx.play("#hit")
	self.health = self.health - dmg
	msg.post("/level#main_gui", "gui_update", { health = self.health })

	msg.post("healthbar/indicator#healthbar", "health", { health = self.health})
	-- go.set("healthbar/go1#healthbar", "health", self.health)
	if self.health <= 0 then
		msg.post("screens:/controller#controller", "scene_change", {
			scene_name = "game_over"
		})
	end
end

function on_message(self, message_id, message, sender)
	-- Add message-handling code here
	-- Learn more: https://defold.com/manuals/message-passing/
	-- Remove this function if not needed
	if message_id == hash("trigger_response") then
		-- print("always other id: " ..  msg.url(message['other_id']))
		-- print("last hit: " ..  msg.url(last_hit_by))
		-- pprint(message)
		if message.enter and hash("weapon_enemy") == message["other_group"] then
			-- pprint("Sender: " .. sender)
			-- pprint(message)
			local dmg = go.get(msg.url(nil, message.other_id, "weapon_swing"), "damage")
			take_damage(self, dmg)
		end
	end
end

function on_input(self, action_id, action)
	if action_id == input_left then
		self.input.x = -1
	elseif action_id == input_right then
		self.input.x = 1
	elseif action_id == input_up then
		self.input.y = 1
	elseif action_id == input_down then
		self.input.y = -1
	elseif action_id == input_attack and action.pressed then
		print("Attack pre")
		attack(self)
	elseif not action_id then -- action_id == nil, so this is a mouse movement event
		-- pprint(action)
		local inputVector = vmath.vector3(action.x, action.y, 0) - vmath.vector3(display_width / 2, display_height / 2, 0)
		local axisVector = vmath.vector3(0, 1, 0)
		if vmath.length(inputVector) ~= 0 then
			self.direction = -angle_between_vectors(inputVector, axisVector)
		end
	end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
